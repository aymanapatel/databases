= Notes on DB engineering 
:toc: 
:icons: font

== Section 02: ACID




=== Transaction


- Collection of queries
- A Unit of Work
- Account  Deposit (SELECT, UPDATE, UPDATE)
    1. `SELECT balance FROM Account WHERE ID=1`
    2. Check if Balance deposited is available
    3. `UPDATE Account SET balance = balance - 100 WHERE ID=1`
    4. `UPDATE Account SET balance = balance + 100 WHERE ID=2`
    5. COMMIT


=== Atomicity

> All queries must succeed. If fail, then rollback everything. `


=== Isolation

> Every transaction is isolated. (Can my inflight transactions see changes made by other transaction)


==== READ phenomena

> READ ugliness due to lack of ISOLAION.

|===
|Type | Description | Example | Links

| DIRTY READS | Some other transaction made a change which was not committed; hence my transaction saw uncommitted change. | image:img/DR.JPG[NRR] | 

| NON-REPEATABLE READS | Read COMMITTED data from an `UPDATE` query from another transaction | image:img/NRR.JPG[NRR] | 

| PHANTOM READS | Read COMMITTED data from an `INSERT` or `DELETE` query from another transaction | image:img/PR.JPG[NRR] | 

|  MISCELLANEOUS - (Lost updates)  | When the value you updated is changed (but not committed) by some other transsaction. Hence, your update is lost. | | 

|===





Ayman: Do example for all 4



==== ISOLATION levels for Inflight transaction


|===
| Isolation Levels | Description | Links

| READ UNCOMMITTED (Least isolated, fastest) | No isolation, any change from outside is visible to the transaction. (All read ugliness is allowed) | 

| READ COMMITTED | Each query in transaction sees only committed stuff| READ COMMITTED vs REPEATABLE READ image:https://www.cybertec-postgresql.com/wp-content/uploads/2018/11/Transaction-isolation-01-768x548.jpg[Image]

| REPEATABLE READ| Each query in transaction only sees committed updates at beginning of transaction | Some DB use versioning for RR. (Example, Cassandra.) Other DB use Lock. Other DB use SHARED LOCK.

| SERIALIZABLE (Most isolated, slowest)| Transactions are serilaized|

|===

image:img/ILvsRP.JPG[isolationlevelvsreadphenomena]

=== Consistency

==== Consistency in Data

1. Defined by user with DDL statements

2. Referential integrity (foreign keys)

3. Atomicity and Isolation leads to data consistency.

Choosing between consistency and performance. Example, likes on social media.



==== Consistency in Reads



WARNING: Relational and NoSQL do not guarantee **Consistency in READS**. Replicas in RDBMS cannot provide consistency in reads.





=== Durability     

> Committed transactionsmust be persisted permanentlyin a non-volatile storage


=== Eventual consistency

WARNING: Relational and NoSQL do not guarantee **Consistency in READS**


== Section 3: Indexing


=== Index Scan vs Index-only Scan

== Section 4: Partitioning


=== Horizantal vs Vertical Partitioning

== Section 5: Sharding



> SQL Pagination with Offset is evil



== Section 6: Concurrency Control


== Section 7: DB replication


== Section 8: DB System Design

=== Build URL shortener DB Design


== Section 9: Introduction to DB Engines


== Section 10: B-Tree DB Engines

==== MyISAM

==== Aria

==== InnoDB


==== XtraDB

==== SQLite


==== BerkleyDB


=== Section 11: LSM Tree DB Engines

==== LevelDB

==== RocksDB

== Section 12: Database Engines Demo

== Section 13: Database Cursors

== Section 14: DB Security 

== Section 15: Homomorphic Encryption (Search Encrypted Databases)


== Section 16: Miscellaneous DB Discussion


=== Distributed Transaction


=== Server-side vs Client-Side DB





